= Demo f√ºr Spring Boot Microservice

In diesem Gradle-basierten Projekt wird gezeigt, wie mit wenig Code ein kompletter Microservice mit voller CRUD
Funktionalit√§t erstellt werden.

== Technologien und Anforderungen
Dieses Projekt nutzt:

- Java 21
- Spring Boot 3.4.5
- Gradle 8.13
- Lombok
- H2

Es sollte auf allen Umgebungen, sogar Windows, ausf√ºhrbar sein, solange `java` verf√ºgbar ist.

== Wie ausf√ºhren?
Im Wurzelverzeichnis kann `./gradlew clean build bootRun` ausgef√ºhrt werden. Danach stehen die REST Endpunkte unter
`http://localhost:8080/api` zur Verf√ºgung.

Daten werden in einer in-memory H2 Datenbank gespeichert. Es wird also nichts persistiert.
Die Initialisierung geschieht mittels der link:src/main/resources/data.sql[data.sql] Datei.

Zur Laufzeit kann √ºber http://localhost:8080/h2-console die H2 Konsole aufgerufen werden.

== Beispiel-Requests
Es gibt f√ºr jeden Request-Typ ein eigenes http-Client Script unter link:./src/main/http/[src/main/http].

Hier aber auch noch eine √úbersicht f√ºr die Verwendung von `curl` bzw. (unter Windows PowerShell) mit `Invoke-WebRequest`.

In den Beispielen verwende ich `jq` zusammen mit `curl`. Das formatiert in diesem Fall nur die Antwort. Wenn es nicht installiert sein sollte, kann es nat√ºrlich weggelassen werden.

[,bash]
.GET Request f√ºr alle verf√ºgbaren Produkte
----
curl -H "Content-Type: application/json" http://localhost:8080/api/products | jq
----

[,powershell]
.GET Request f√ºr alle verf√ºgbaren Produkte (Windows)
----
Invoke-WebRequest -Uri "http://localhost:8080/api/products/" -Method GET | Select-Object -ExpandProperty Content
----

[,bash]
.GET Request f√ºr spezifisches Produkt
----
curl -H "Content-Type: application/json" http://localhost:8080/api/products/1 | jq
----

[,powershell]
.GET Request f√ºr alle verf√ºgbaren Produkte (Windows)
----
Invoke-WebRequest -Uri "http://localhost:8080/api/products/1" -Method GET | Select-Object -ExpandProperty Content
----

[,bash]
.POST Request, um neues Produkt hinzuzuf√ºgen
----
curl -X POST http://localhost:8080/api/products \
  -H "Content-Type: application/json" \
  -d '{"name":"Tablet","description":"New tablet model","price":499.99}'
----

[,powershell]
.POST Request, um neues Produkt hinzuzuf√ºgen
----
$body = @{
  name = "Tablet"
  description = "New tablet model"
  price = 499.99
} | ConvertTo-Json
Invoke-WebRequest -Uri "http://localhost:8080/api/products" -Method POST -Body $body -ContentType "application/json" | Select-Object -ExpandProperty Content
----

[,bash]
.DELETE Request
----
curl -X DELETE http://localhost:8080/api/products/1
----

[,powershell]
.DELETE Request (Windows)
----
Invoke-WebRequest -Uri "http://localhost:8080/api/products/1" -Method DELETE
----

== Docker
Das Projekt beinhaltet ein simples link:Dockerfile[Dockerfile].

.Image bauen
----
docker build -t product-service:latest .
----

.Container bauen und ausf√ºhren (Beenden mit Ctrl+C)
----
## Container wird nach beenden gel√∂scht (--rm)
docker run --rm --name product-service-tmp -p 8080:8080 product-service:latest
----

== Kubernetes
Nat√ºrlich sollten wir jetzt auch in Kubernetes deployen.

Lokal benutzen wir https://minikube.sigs.k8s.io/docs/[Minikube]. Dies kann wie folgt gestartet werden:

.Minikube auf MacOS starten
----
minikube start --cpus=4 --memory=8g --driver=docker
----

.Minikube auf WIndows starten
----
minikube start --cpus=4 --memory=8g --driver=hyperv
----

Dann setzen wir die Umgebung so, dass wir innerhalb von Minikube bauen:

.MacOS Umgebung f√ºr Minikube Build setzen
----
eval $(minikube docker-env)
----

[,powershell]
.Windows Umgebung f√ºr Minikube Build setzen
----
minikube docker-env | Invoke-Expression
----

und dann k√∂nnen wir bauen:

.Docker Build wie zuvor
----
docker build -t product-service:latest .
----

Und dann geht es ans Deployment:

.Deployment ins Minikube
----
kubectl apply -f k8s/k8s-deployment.yml
kubectl apply -f k8s/k8s-service.yml
----


.Zugriff auf Services
[,bash]
----
minikube service product-service --url
----

.Logs anzeigen
[,bash]
----
kubectl logs -f deployment/product-service
----

== Event-Driven-Development Beispiel mit RabbitMQ
In der link:docker-compose.yml[docker-compose.yml] ist alles so konfiguriert, dass ein RabbitMQ gestartet wird, der lokal unter http://localhost:5672 (Username & Passwort: _guest_) verf√ºgbar ist.

Das Starten ist denkbar einfach:

.Starten von RabbitMQ und der Anwendung in Docker
----
docker compose up
----

Beim Erzeugen von neuen Produkten wird nun ein Event ver√∂ffentlicht. Auf dieses lauscht `ProductEventListener` und schreibt ins Log:

.Beispiel Log-Zeile, wenn Produkt erzeugt wurde
----
product-service-1  | üì¶ Neues Produkt erstellt: ID=4, Name=circuit
----

Am Einfachsten ist es, einfach link:src/main/http/02_add_product.http[02_add_product.http] auszuf√ºhren, um zuf√§llige Produkte hinzuzuf√ºgen.

Beendet werden kann entweder mit _Ctrl+C_ oder, wenn `docker compose up -d` ausgef√ºhrt wurde und es damit im Hintergrund l√§uft, mit `docker compose down`.
